import numpy as np

sbox = [
0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
 ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
 ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
 ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
 ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
 ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
 ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
 ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
 ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
 ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
 ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
 ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
 ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
 ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
 ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
 ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16
]

def subbyte(i):
    if i < 0 or i>255:
        print("Error! i in range [0,255]")
        exit(1)
    return sbox[i]

def shift_row_index(i):
    if i %4 == 0: 
        return i 
    elif i == 1:
        return 5
    elif i == 5:
        return 9
    elif i == 9:
        return 13
    elif i == 13:
        return 1
    
    elif i == 2:
        return 10
    elif i == 6:
        return 14
    elif i == 10:
        return 2
    elif i == 14:
        return 6

    elif i == 3:
        return 15
    elif i == 7:
        return 3
    elif i == 11:
        return 7
    elif i == 15:
        return 11 
    else:
        print("Error: i should be in range [0,15]")
        exit(1)


def inv_shift_row_index(i):
    if i %4 == 0: 
        return i 
    elif i == 5:
        return 1
    elif i == 9:
        return 5
    elif i == 13:
        return 9
    elif i == 1:
        return 13
    
    elif i == 10:
        return 2
    elif i == 14:
        return 6
    elif i == 2:
        return 10
    elif i == 6:
        return 14

    elif i == 15:
        return 3
    elif i == 3:
        return 7
    elif i == 7:
        return 11
    elif i == 11:
        return 15 
    else:
        print("Error: i should be in range [0,15]")
        exit(1)



def process_input(filename):
    correct_ciphers = []
    faulty_ciphers = []
    with open(filename, "r") as f:
        for lines in f:
            data = lines.split(":")
            cipher_type = data[0].strip()
            cipher_text = data[1].strip()
            # print(cipher_type, cipher_text)
            if cipher_type == "Faulty":
                faulty_ciphers.append(str_to_bytes(cipher_text))
            elif cipher_type == "Correct":
                correct_ciphers.append(str_to_bytes(cipher_text))
    return correct_ciphers, faulty_ciphers

def bytes_to_str(arr):
    s = ''
    for i in arr:
        s = s+ "{:02x}".format(i)
    return s  

def str_to_bytes(line):
    arr = [ '' for i in range(16)]

    k = 0
    for i in range(len(line)):
        arr[k]= arr[k]+line[i]
        i = i+1
        if i%2 == 0:
            k = k+1 
    for i in range(16):
        arr[i] = int(arr[i],base=16)
    return arr 

def print_state(a):
    for i in range(4):
        for j in range(4):
            print("{:02x}".format(a[i*4+j]), end=" ")
    print()

def dfa_bit_fault(c, ds):
    
    locations = [0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80]
    recovered = []
    for j in range(16):
        count = [0]*255
        for x in range(255):
            for e in locations:
                for d in ds:
                    lhs = c[0][shift_row_index(j)] ^ d[shift_row_index(j)]
                    rhs = subbyte(x) ^ subbyte(x ^ e)
                    if (lhs == rhs):
                        count[x] = count[x]+1
        recovered.append(np.argmax(count))
    return recovered

def find_non_zero_locations(c, d):
    res = []
    for i in range(16):
        if (c[i] ^ d[i] != 0):
            res.append(i)
    return res 


if __name__ == "__main__":
    input_filename = "set1.txt"
    correct_ciphers = []
    faulty_ciphers = []
    correct_ciphers, faulty_ciphers = process_input(input_filename)

    recovered = dfa_bit_fault(correct_ciphers,faulty_ciphers)
    print(bytes_to_str(recovered))
    